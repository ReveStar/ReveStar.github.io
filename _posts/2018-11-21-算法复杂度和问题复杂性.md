---
layout:     post
title:      算法复杂度和问题复杂性
subtitle:   算法复杂度定义以及简单示例
date:       2018-11-21
author:     ZHD 
header-img: img/post-bg-algorithm.jpg
catalog: true
tags:
    - algorithm
    - note 
---
## 前言
算法设计与分析的一些基本的概念，如算法复杂度以及算法复杂性的概念。其次是度量算法复杂度的方法，以及算法复杂度的表示方法。

## 算法复杂度
### 排序算法的复杂度
<table>
    <tr>
        <th>算法</th>
        <th>最坏情况</th>
        <th>平均情况</th>      
    </tr>
    <tr>
        <td>插入排序</td>
        <td>$$O(n^2)$$</td>
        <td>$$O(n^2)$$</td>
    </tr>
    <tr>
        <td>冒泡排序</td>
        <td>$$O(n^2)$$</td>
        <td>$$O(n^2)$$</td>
    </tr>
    <tr>
        <td>快速排序</td>
        <td>$$O(n^2)$$</td>
        <td>$$O(nlogn)$$</td>
    </tr>
    <tr>
        <td>堆排序</td>
        <td>$$O(nlogn)$$</td>
        <td>$$O(nlogn)$$</td>
    </tr>
    <tr>
        <td>二分归并排序</td>
        <td>$$O(nlogn)$$</td>
        <td>$$O(nlogn)$$</td>
    </tr>
</table>

## 算法复杂性与货郎问题
### 货郎问题
#### 问题内容
    有n个城市，一直任两个城市之间的距离。求一条每个城市恰好经过一次的回路，使总长度最短。

#### 建模与算法
输入 <br>
有穷个的城市集合$$C=\{c_1,c_2,c_3,...,c_n\}$$
,距离$$d(c_i,c_j) = d(c_j,c_i)\in Z^+ ,1\le i\lt j \le n$$<br>
解 <br>
1,2...,n的排列$$k_1,k_2,...,k_n$$ 使得 <br>
$$min{ \sum_{i=1}^{n-1} d(c_k{_{_i}},c_k{_{_{i+1}}}) + d(c_k{_{_n}},c_k{_{_1}})}$$

现状是：至今没有找到有效的算法。（这里的有效算法是指多项式时间的算法）
像这样的问题为NP-hard问题。且计算复杂理论的核心是NP完全理论.



## 算法及其时间复杂度
### 算法
#### 算法的定义
1.有限指令的序列 2.这个指令序列确定了解决某个问题的一系列运算和操作。
#### 算法A解决问题P
即把问题P的任何实例作为算法A的输入，每一步计算时确定性的，A能够在有限步停机，输出该实例的正确的解。
### 基本运算和输入规模
* 算法时间复杂度：针对指定基本算法，计数算法所做的运算次数
* 基本运算：比较，叫法，乘法，置指针，交换···
* 输入规模：输入串编码长度，通常用下述参数度量:数组元素的多少，调度问题的任务个数，图的顶点数和边数等
* 给定问题和基本运算就决定了一个算法类

#### 输入规模
* 排序：数组中元素的个数n
* 检索：被检索数组的元素个数n
* 整数乘法：两个整数的位数m,n
* 矩阵乘法：矩阵的行列数i，j，k
* 图的遍历：图的顶点数n，边数m
* ···

#### 基本运算
* 排序：元素之间的**比较**
* 检索：被检索元素x与数组元素的**比较**
* 整数乘法：每位数字相乘一次，m位和n位整数相乘要做**mn次位乘**
* 矩阵相乘：每对元素乘一次，ixj矩阵和jxk矩阵相乘要做**ijk次乘法**
* 图的遍历：置指针

#### 两种时间复杂度
* 最坏时间复杂度W(n)：算法求解输入规模为n的实例所需要的最长时间
* 平均时间复杂度A(n)：同样规模为n的输入实例的概率分布下，算法求解这些实例所需要的平均时间  

### A(n)计算公式
设S是规模为n的实例集
实例$$I\in S$$的概率是$$P_I$$
算法对实例I执行的基本运算次数是$$t_I$$
则$$ A(n) = \sum_{I \in S} P_It_I  $$
在某些情况下可以假定每个输入实例的概率相等

## 函数渐进的界
### 大O符号
#### 定义
f和g是定义域为自然数N上的函数，若存在正数c和$$n_0$$,使得对一切$$n \ge n_0$$有$$0 \le f(n) \le cg(n) $$ 成立，则称f(n)的渐进上界是g(n),记作 $$f(n) = O(g(n))$$

#### 例子
设$$f(n) = n^2 + n$$,则
$$f(n) = O(n^2)$$,取$$c=2，n_0 = 1$$即可
$$f(n) = O(n^3)$$,取$$c=1，n_0 = 2$$即可

#### Tips
* $$f(n)=O(g(n))$$，f(n)的阶不高于g(n)的阶
* 可能存在多个整数c，只要指出一个即可
* 对于前面有限个值可以不满足不等式
* 常函数可以写作O(1)

### 大$$\Omega$$符号  
#### 定义
设f和g是定义域为自然数集N上的函数。若存在正式c和$$n_0$$，使得对一切$$n \ge n_0$$有
$$0 \le cg(n)\le f(n)$$
成立，则称$$f(n)$$的渐进下界是$$g(n)$$,记作
$$f(n)=\Omega (g(n))$$

#### 例子
设$$f(n)=n^2+n$$，则
$$f(n) = \Omega (n^2)$$，取c=1，$$n_0 =1$$即可
$$f(n)= \Omega (100n)$$,取$$c=1/100,n_0=1$$即可

#### Tips
* $$f(n)= \Omega (g(n)), f(n)$$的阶不低于$$g(n)$$的阶
* 可能存在多个正数c，指出一个即可
* 对前面有限个n值可以不满足上述不等式

### 小$$O$$符号  
#### 定义
设f和g是定义域为自然数集N上的函数。对于任意的正数c都存在$$n_0$$，使得对一切$$n \ge n_0$$有
$$0 \le f(n)\lt cg(n)$$
成立，则记作
$$f(n)=o (g(n))$$

#### 例子
设$$f(n)=n^2+n$$，则
$$f(n) = o (n^3)$$，$$c \ge 1$$ 时显然成立，因为$$n^2+n\lt cn^3 (n_0=2)$$
任给$$1 \gt c \gt 0$$,取$$n_0\gt \lceil2/c\rceil$$即可，因为
$$cn \ge cn_0 \gt 2 (当n \ge n_0)$$
$$n^2+n \lt 2n^2 \lt cn^3$$

#### Tips
* $$f(n)= o (g(n)), f(n)$$的阶低于$$g(n)$$的阶
* 对于不同的正数c,$$n_0$$不一样，c越小$$n_0$$越大
* 对前面有限个n值可以不满足上述不等式

### 小$$\omega$$符号  
#### 定义
设f和g是定义域为自然数集N上的函数。对于任意的正数c都存在$$n_0$$，使得对一切$$n \ge n_0$$有
$$0 \le cg(n)\lt f(n)$$
成立，则记作
$$f(n)=\omega (g(n))$$

#### 例子
设$$f(n)=n^2+n$$，则
$$f(n) = \omega (n)$$
不能写$$f(n)=\omega (n^2)$$,因为取c=2时，不存在$$n_0$$使得对一切$$n\ge n_0$$使$$cn^2 = 2n^2 \lt n^2+n$$成立

#### Tips
* $$f(n)= \omega (g(n)), f(n)$$的阶高于$$g(n)$$的阶
* 对于不同的正数c,$$n_0$$不等，c越大$$n_0$$越大
* 对前面有限个n值可以不满足上述不等式

### $$\theta$$符号
#### 定义
若$$ f(n) = O(g(n)) $$ 且 $$f(n) = \Omega (g(n))$$
则记作 $$ f(n) = \theta (g(n)) $$

#### 例子
$$ f(n) = n^2 + n,g(n) = 100n^2 $$
那么有$$ f(n) = \theta (g(n)) $$

#### Tips
* f(n)的阶与g(n)的阶相等
* 对前面有限个n值可以不满足条件




